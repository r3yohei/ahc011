# AHC011参加記録(20220528~20220605)
## まえがき
- AHCは過去3回参戦
- Rating: 835(緑)
- 山登り･貪欲･エスパーを武器に戦ってきた
- メイン言語はPythonだが，今回初めてRustを使用
    - Rustの方が高速な分，シミュレーションで打てる手数が多いだろうと予想
    - メモリ管理も頑張りようがある
    - ソースコードが膨大になってもバグをはらみづらい
    - などが表向きの理由で，本心はなんかかっこいいからです
## 20220528
- 始まりました
- 何もしないを提出 → 2,869,199
- ウェブ版シミュレータで遊んでみる
    - 1回も解けない
    - こういうパズルに詳しくもないのでドメイン知識がない状態で方針を考え始める
- scoreの計算ロジックを見る
    - 木は大きいほどいい
    - 全域木は少ない手番で完成したほうがいい
    - score計算関数を実装する
- 考察をする
    - 基本的にはグラフのように扱う
    - 与えられたタイルを扱いやすくする
        - 各タイルを3x3に細分する
            - '#': 通れない, '.': 通れる
            - タイル0: [['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#']]
            - タイル7: [['#', '.', '#'], ['.', '.', '.'], ['#', '#', '#']]
            - タイルf: [['#', '.', '#'], ['.', '.', '.'], ['#', '.', '#']]
        - 元のNxN盤面を各タイルを上のように変換することで，3Nx3Nのタイルにし，グラフとして扱いやすくする→実装
        - 例えば木の大きさは，この3Nx3Nグラフ上の任意の視点から到達可能な頂点のうち，3x3タイルの真ん中の個数
            - これは，BFSで出せる→実装
        - 閉路があると木としてカウントされない
            - 閉路検出はDFSでできる→未実装
    - 山登り(?)をする
        - 山登りと貪欲の区別があまり明確についてないです
        - 空きマスの上下左右の動かせるタイルのうち，動かすことでそこを始点とした木の大きさが最も大きくなるタイルを動かす(伝われ)
        - 最大T回までの試行の中で，最も木が大きくなった手順を保存し，最後に出力する
        - 7,016,380で少し改善
- その他
    - この日のABCは爆死して，レートが下がりました．茶色安定です．

## 20220529
- プライベートの用事で不参戦

## 20220530
- 山登りを少し改良
    - 前回提出は山登り1回のみだったが，繰り返しシミュレートするようにした
    - 各手番で取りうるアクションからランダムに選び，木の大きさが改善するなら即採用，すべてのアクションで改善しないならランダムにどれかをやる
    - 回数制限Tまで登ったらそれまでのベストの手順を保存し，再度1からシミュレートし始める
    - 13,134,145でそこそこ改善
    - 長らくこのスコアを塗り替えられなくなる．．

## 20220531
- ビームサーチを検討する
    - 山登りはゲーム木を考えると，自身の子だけをずっと葉まで見続けるイメージ
    - 別の兄弟を辿っているともう少し良い手がありえたかもしれない
    - 盤面の状態を保持するGameState構造体を作成
    - 各手番で，木が大きい順に4(beam幅)個のGameStateを優先度付きキューから取り出し，それらの合法手をすべて試して優先度付きキューに入れる
    - 競プロスマブラ部でお世話になっているサンダーさんの記事を参考に
    - https://qiita.com/thun-c/items/058743a25c37c87b8aa4
    - C++で書かれているが，がんばってRustに移植
    - beam幅を変えたり色々やってみるものの，10,000,000前後を停滞
        - 収束が早く，局所解にすぐに陥っていそう

## 20220601
- chokudaiサーチを検討する
    - ビームサーチは根本が同じ盤面を探索するので，解の収束が早い
    - そこで，一度深くまで探索しても再度浅い位置から探索をやり直し，多様性を持たせるためにchokudaiサーチを入れる
        - 配列beam[T]に優先度付きキューをT個初期化
        - 手番iでbeam[i]からGameStateを取り出す
        - 合法手をすべて試し，結果のGameStateをbeam[i+1]の優先度付きキューに入れる
        - T回探索したらもう一度1から探索を再開する
        - このとき，各手番iでbeam[i]から取り出したGameStateを再度見ることがないので，同じ手を評価することなく浅いところから再度やり直せる
        - しかし，ここらから実行時間とメモリ制限がきつくなってくる．．．
        - しかもせいぜい11,000,000くらい

## 20220602
- やり残したことを考える
    - 閉路検出
        - さくっとDFSで実装
        - こいつのお陰で13,521,742となり，初めて山登りに勝つ